{
    "contents" : "cv.l1tf <- function (x, y, weights, offset = NULL, lambda = NULL, \n                     type.measure = c(\"mse\", \"deviance\", \"class\", \"auc\", \"mae\"), nfolds = 10, foldid, \n          grouped = TRUE, keep = FALSE, parallel = FALSE, ...) \n{\n  if (missing(type.measure)) \n    type.measure = \"default\"\n  else type.measure = match.arg(type.measure)\n  if (!is.null(lambda) && length(lambda) < 2) \n    stop(\"Need more than one value of lambda for cv.glmnet\")\n  N = nrow(x)\n  if (missing(weights)) \n    weights = rep(1, N)\n  else weights = as.double(weights)\n  y = drop(y)\n  glmnet.call = match.call(expand.dots = TRUE)\n  which = match(c(\"type.measure\", \"nfolds\", \"foldid\", \"grouped\", \n                  \"keep\"), names(glmnet.call), F)\n  if (any(which)) \n    glmnet.call = glmnet.call[-which]\n  glmnet.call[[1]] = as.name(\"glmnet\")\n  glmnet.object = glmnet(x, y, weights = weights, offset = offset, \n                         lambda = lambda, ...)\n  glmnet.object$call = glmnet.call\n  is.offset = glmnet.object$offset\n  lambda = glmnet.object$lambda\n  if (inherits(glmnet.object, \"multnet\")) {\n    nz = predict(glmnet.object, type = \"nonzero\")\n    nz = sapply(nz, function(x) sapply(x, length))\n    nz = ceiling(apply(nz, 1, median))\n  }\n  else nz = sapply(predict(glmnet.object, type = \"nonzero\"), \n                   length)\n  if (missing(foldid)) \n    foldid = sample(rep(seq(nfolds), length = N))\n  else nfolds = max(foldid)\n  if (nfolds < 3) \n    stop(\"nfolds must be bigger than 3; nfolds=10 recommended\")\n  outlist = as.list(seq(nfolds))\n  if (parallel && require(foreach)) {\n    outlist = foreach(i = seq(nfolds), .packages = c(\"glmnet\")) %dopar% {\n  which = foldid == i\n  if (is.matrix(y)) \n    y_sub = y[!which, ]\n  else y_sub = y[!which]\n  if (is.offset) \n    offset_sub = as.matrix(offset)[!which, ]\n  else offset_sub = NULL\n  glmnet(x[!which, , drop = FALSE], y_sub, lambda = lambda, \n         offset = offset_sub, weights = weights[!which], ...)\n    }\n  } else {\n  for (i in seq(nfolds)) {\n    which = foldid == i\n    if (is.matrix(y)) \n      y_sub = y[!which, ]\n    else y_sub = y[!which]\n    if (is.offset) \n      offset_sub = as.matrix(offset)[!which, ]\n    else offset_sub = NULL\n    outlist[[i]] = glmnet(x[!which, , drop = FALSE], \n                          y_sub, lambda = lambda, offset = offset_sub, \n                          weights = weights[!which], ...)\n  }\n}\nfun = paste(\"cv\", class(glmnet.object)[[1]], sep = \".\")\ncvstuff = do.call(fun, list(outlist, lambda, x, y, weights, \n                            offset, foldid, type.measure, grouped, keep))\ncvm = cvstuff$cvm\ncvsd = cvstuff$cvsd\ncvname = cvstuff$name\nout = list(lambda = lambda, cvm = cvm, cvsd = cvsd, cvup = cvm + \n             cvsd, cvlo = cvm - cvsd, nzero = nz, name = cvname, glmnet.fit = glmnet.object)\nif (keep)\n  out = c(out, list(fit.preval = cvstuff$fit.preval, foldid = foldid))\nlamin = if (type.measure == \"auc\")\n  getmin(lambda, -cvm, cvsd)\nelse getmin(lambda, cvm, cvsd)\nobj = c(out, as.list(lamin))\nclass(obj) = \"cv.glmnet\"\nobj\n}",
    "created" : 1417362495655.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1497844603",
    "id" : "FAED23C2",
    "lastKnownWriteTime" : 0,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled5"
    },
    "source_on_save" : false,
    "type" : "r_source"
}