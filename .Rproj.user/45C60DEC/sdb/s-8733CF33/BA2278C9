{
    "contents" : "# Ejercicio de repaso - Regresion Logistica\nrm(list = ls(all=TRUE))\n\n# Saco notacion cientifica\noptions(scipen=666)\n\n# setwd(path)\nrm(list = ls(all=TRUE))\nd = read.table(\"Adult.txt\", sep=\"\\t\", header=TRUE)\n\n### 1.1.1  \n# Separe las poblaciones en entrenamiento y validación en forma aleatoria. \n# Indique que cantidad de casos quedaron para cada ambiente.\n\nlibrary(caret)\ntd <- sapply(d, class)\n\n# Me fijo los valores unicos de cada variable\nln <- apply(d, 2, function(x) length(unique(x)))\n\n# Si tiene más de 16 valores la convierto como factor, \n# después será convertida a categorica\nfact = names(ln[ln < 17])\n\nd <- d[order(d$Clase, decreasing=TRUE), ]\n\n# Defino como factor a las nominales\nfor(j in fact) d[, j] <- as.factor(as.character(d[, j]))\n\nd$Clase <- factor(ifelse(d$Clase == 1, 1, 0), levels=c(1, 0))\n\n# d$Clase <- factor(ifelse(d$Clase == 1, 'ALTO', 'BAJO'), levels = c(\"ALTO\", \"BAJO\"))\ntd <- sapply(d, class)\n\n### Calculo cuantos NA hay por columna\nna <- apply(d, 2, function(x) sum(is.na(x)))\n\nprint('variables con NAs')\nna[na !=0]\n\n# Los NAs estan en variables categoricas, agrego una categoria y listo\n# Para eso defino a la funcion addNA\n# d$WorkClass <- addNA(d$WorkClass)\n# d$Occupation <- addNA(d$Occupation)\n\n# Filtro registros con NAs\n# Usar si no usas la funcion anterior\nd <- d[complete.cases(d), ]\n\nif(sum(is.na(d)) != 0)\n  stop('Todavia hay NAs')\n\n### Split en training y testing (sampleo estratificado por la clase) \n# Necesita al paquete caret\nset.seed(123)\nin_train <- createDataPartition(d$Clase, p=0.7, list=F)\n\ntrain <- d[in_train, ]\ntest <- d[-in_train, ]\n\nprint(dim(train))\nprint(dim(test))\n\n# 1.1.2  Formule el mejor modelo posible de regresión logística\nlibrary(leaps)\n\n# Genero dos modelos el nulo y el completo\nnull <- glm(formula=Clase ~ 1, data=train, family='binomial')\nfull <- glm(formula=Clase ~ ., data=train, family='binomial')\n\n# Foward\nfwd <- step(null, scope=list(lower=null, upper=full), direction=\"forward\", na.action='na.omit')\n# Stepwise\nstep <- step(null, scope=list(lower=null, upper=full), direction=\"both\", na.action='na.omit')\n# Backward\nback <- step(full, data=Housing, direction=\"backward\", na.action='na.omit')\n\n# Grabo lo anterior\n# Se puede leer de nuevo usando load('glm.RData')\n\n#load('glm.RData')\n\nlibrary(pROC)\nlibrary(caret)\n\nplot_rocs <- function(train, test, model, titulo='ROC stepwise'){\n  # Genera las predicciones de entrenamiento y testeo\n  probs_train <- predict(model, newdata=train, type=\"response\")\n  probs_test <- predict(model, newdata=test, type=\"response\")\n  \n  par(mfrow=c(1, 2))\n  \n  # Grafica la ROC de training en el cuadrante izquierdo\n  roc_train <- plot.roc(Clase ~ probs_train, data=train,  \n                        main=paste0(titulo, ' train'), percent=TRUE,  print.auc=TRUE,\n                        thresholds=\"best\", print.thres='best', col=\"#1c61b6\")\n  # Grafica la ROC de testing en el cuadrante derecho\n  roc_test <- plot.roc(Clase ~ probs_test, data=test,  \n                        main=paste0(titulo, ' test'), percent=TRUE,  print.auc=TRUE,\n                       thresholds=\"best\", print.thres='best', col=\"#008600\")\n  par(mfrow=c(1, 1))\n  # Devuelve una lista con los siguientes elementos\n  list(roc_train=roc_train, roc_test=roc_test, \n       probs_train=probs_train, probs_test=probs_test)\n}\n\n# 1.1.3 Calcular el AUC y las ROC en train y testing\nroc_fwd <- plot_rocs(train, test, fwd, \"ROC Foward\")\nroc_step <- plot_rocs(train, test, step, \"ROC Stepwise\")\nroc_back <- plot_rocs(train, test, back, \"ROC Backward\")\n\n# Stepwise y foward encuentran los mismos modelos (la formula es la misma)\nidentical(fwd$formula, step$formula)\n# backward encuentra otra formula\nidentical(back$formula, step$formula)\n\n# Genero una lista con todos los modelos\nmodelos <- list(fwd=fwd, step=step, back=back)\n\n# Uso \"[[\" para extraer elementos por su nombre\n# Formula de cada modelo\nlapply(modelos, '[[', 'formula')\n\n# Que variables fueron entrando y como vario el AIC\nlapply(modelos, '[[', 'anova')\n\n# 1.1.4  Selecciones el 10% de los trabajadores en el ambiente de validación de acuerdo a la siguiente lógica. \n# Entregue los resultados indicados:\n# a)\tAl azar e indique la cantidad de trabajadores que llegaron a superar los 50.000 dólares anuales.\n# RTA: 230\n# b)\tUtilizando el modelo desarrollado en el punto 1.1.2 e \n# indique la cantidad de trabajadores que llegaron a superar los 50.000 dólares anuales.\n# RTA: 798\n# print(tbl)\n# pred    1    0\n#     1  798  124\n#     0 1497 6796\n\nset.seed(123)\n\nin_validation <- createDataPartition(test$Clase, p=0.1, list=F)\nvalidation <- test[in_validation, ]\n\n# Porcentaje de clase = ALTO al azar en el 10%\nclase_10pct <- sum(validation$Clase == 1)\n\ncontrasts(train$Clase)\nprobs <- 1 - predict(fwd, newdata=test, type=\"response\")\n\n# probs <- 1 - probs\nquantile(probs, seq(0, 1, 0.1))\ncuts <- quantile(probs, seq(0, 1, 0.1))\nqt_90 <- quantile(probs, 0.9)\n\n# probs > al percentil 90\n# Es el 10% con mejor probabilidad \nsum(probs > qt_90[[1]])\n\npred <- factor(ifelse(probs > qt_90[[1]], 1, 0), levels=c(1, 0))\ntbl <- table(pred, test$Clase)\ntbl\n\n# LIFT (a mano)\nlift <- tbl[1,1] / clase_10pct\nprint(lift)\n\n\n### ROC y Lift de RWD\nlibrary(ROCR)\n# Curva ROC\npred <- prediction(probs, test$Clase)\nroc_perf <- performance(pred, measure=\"tpr\", x.measure=\"fpr\")\nplot(roc_perf, main=\"ROC Curve\", colorize=T)\n\n# Lift\nperf_lift <- performance(pred, measure=\"lift\", x.measure=\"rpp\")\nplot(perf_lift, main=\"lift curve\", colorize=T)\n\n# 1.1.5\tCalcular y/o obtener los siguientes resultados: \n# a)\tIndicar en cuanto sería el impacto en modificar una unidad de por lo menos una variable continua del modelo. \n# b)\tIndicar si hay puntos incluyentes con COOK.\n# c)\tIndicar que método de selección de variables se utilizó y explicar su funcionamiento.\n# d)\tMostrar el estadístico de Hosmer-Lemeshow en el último paso del modelo.\n\n\n### a)\n# Odds ratios\nOR <- exp(data.frame(coef(fwd)))\n\n# Variable Continua Age\n# Ante un aumento en una unidad en la variable X, se espera que aumente sus odds en:\nOR[row.names(OR) == 'Age', ]\n\npar(mfrow=c(2,2))\nplot(fwd)\npar(mfrow=c(1,1))\n\n\n### b)\n\n# imI <- influence.measures(fwd)\ncooks <- cooks.distance(fwd)\nquantile(cooks, seq(0.9,1,0.01))\n\n# Estas observaciones son puntos influyentes\ndrop_rows <- names(cooks[cooks > 0.00065237178])\ntrain[drop_rows, ]\n\n\n### c) Metodo de selección de variables: Stepwise.\n# Forward selection, which involves starting with no variables in the model, testing the addition of each variable using a chosen model comparison criterion, adding the variable (if any) that improves the model the most, and repeating this process until none improves the model.\n# Backward elimination, which involves starting with all candidate variables, testing the deletion of each variable using a chosen model comparison criterion, deleting the variable (if any) that improves the model the most by being deleted, and repeating this process until no further improvement is possible.\n# Bidirectional elimination, a combination of the above, testing at each step for variables to be included or excluded.\n\n\n### d)\nlibrary('ResourceSelection')\nhl <- hoslem.test(fwd$y, fitted(fwd), g=10)\ncbind(hl$observed,hl$expected)\nhl\n\nsave.image('glm.RData')\n\n\n### AUC - GLMNET\nglmnet::auc(as.numeric(as.character(test$Clase)), as.vector(probs))\n\ny <- as.numeric(as.character(test$Clase))\nprob <- as.vector(probs)\n\n### AUC usando pROC\npROC::auc(y, prob)\nplot.roc(y, prob)\n\n# Calculo a mano del AUC (como lo hace glmnet, mucho más rápido)\nrprob = rank(prob)\nn1 = sum(y)\nn0 = length(y) - n1\nu = sum(rprob[y == 1]) - n1 * (n1 + 1)/2\nu/(n1 * n0)\n\nsave.image('glm_resultados.RData')\n",
    "created" : 1417207278576.000,
    "dirty" : true,
    "encoding" : "LATIN1",
    "folds" : "",
    "hash" : "1512384352",
    "id" : "BA2278C9",
    "lastKnownWriteTime" : 1417400713,
    "path" : "~/Desktop/dm/glm/glm.R",
    "project_path" : "glm.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}